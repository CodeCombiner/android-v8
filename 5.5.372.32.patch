From b6a03fadf7868dcbf3c8e5eff40b7fc1af9f1eeb Mon Sep 17 00:00:00 2001
From: plamen5kov <plamen.krasimirov.petkov@gmail.com>
Date: Thu, 1 Dec 2016 15:32:17 +0200
Subject: [PATCH] nativescript patch for 5.4.500.43

---
 BUILD.gn                       |   2 +
 build/config/gcc/BUILD.gn      | 123 ++++++++++++++++++++++
 src/V8NativeScriptExtension.cc | 231 +++++++++++++++++++++++++++++++++++++++++
 src/V8NativeScriptExtension.h  |  26 +++++
 src/api.cc                     |  18 +++-
 5 files changed, 398 insertions(+), 2 deletions(-)
 create mode 100644 build/config/gcc/BUILD.gn
 create mode 100644 src/V8NativeScriptExtension.cc
 create mode 100644 src/V8NativeScriptExtension.h

diff --git a/BUILD.gn b/BUILD.gn
index dcefe37..1e68006 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -818,6 +818,8 @@ v8_source_set("v8_base") {
     "include/v8-version.h",
     "include/v8.h",
     "include/v8config.h",
+    "src/V8NativeScriptExtension.cc",
+    "src/V8NativeScriptExtension.h",
     "src/accessors.cc",
     "src/accessors.h",
     "src/address-map.cc",
diff --git a/build/config/gcc/BUILD.gn b/build/config/gcc/BUILD.gn
new file mode 100644
index 0000000..27942cd
--- /dev/null
+++ b/build/config/gcc/BUILD.gn
@@ -0,0 +1,123 @@
+# Copyright 2014 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/compiler/compiler.gni")
+import("//build/config/sanitizers/sanitizers.gni")
+import("//build/config/sysroot.gni")
+import("//build/toolchain/toolchain.gni")
+
+# This config causes functions not to be automatically exported from shared
+# libraries. By default, all symbols are exported but this means there are
+# lots of exports that slow everything down. In general we explicitly mark
+# which functiosn we want to export from components.
+#
+# Some third_party code assumes all functions are exported so this is separated
+# into its own config so such libraries can remove this config to make symbols
+# public again.
+#
+# See http://gcc.gnu.org/wiki/Visibility
+config("symbol_visibility_hidden") {
+  # Note that -fvisibility-inlines-hidden is set globally in the compiler
+  # config since that can almost always be applied.
+  cflags = [ "-fvisibility=default" ]
+}
+
+# This config is usually set when :symbol_visibility_hidden is removed.
+# It's often a good idea to set visibility explicitly, as there're flags
+# which would error out otherwise (e.g. -fsanitize=cfi-unrelated-cast)
+config("symbol_visibility_default") {
+  cflags = [ "-fvisibility=default" ]
+}
+
+# The rpath is the dynamic library search path. Setting this config on a link
+# step will put the directory where the build generates shared libraries into
+# the rpath.
+#
+# It's important that this *not* be used for release builds we push out.
+# Chrome uses some setuid binaries, and hard links preserve setuid bits. An
+# unprivileged user could gain root privileges by hardlinking a setuid
+# executable and then adding in whatever binaries they want to run into the lib
+# directory.
+#
+# Example bug: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=520126
+#
+# This is required for component builds since the build generates many shared
+# libraries in the build directory that we expect to be automatically loaded.
+# It will be automatically applied in this case by :executable_ldconfig.
+#
+# In non-component builds, certain test binaries may expect to load dynamic
+# libraries from the current directory. As long as these aren't distributed,
+# this is OK. For these cases use something like this:
+#
+#  if (is_linux && !is_component_build) {
+#    configs += [ "//build/config/gcc:rpath_for_built_shared_libraries" ]
+#  }
+config("rpath_for_built_shared_libraries") {
+  if (!is_android) {
+    # Note: Android doesn't support rpath.
+    if (shlib_subdir != ".") {
+      rpath_link = "${shlib_subdir}/"
+    } else {
+      rpath_link = "."
+    }
+    ldflags = [
+      # Want to pass "\$". GN will re-escape as required for ninja.
+      "-Wl,-rpath=\$ORIGIN/${rpath_link}",
+      "-Wl,-rpath-link=${rpath_link}",
+    ]
+  }
+}
+
+# Settings for executables.
+config("executable_ldconfig") {
+  # WARNING! //sandbox/linux:chrome_sandbox will not pick up this
+  # config, because it is a setuid binary that needs special flags.
+  # If you add things to this config, make sure you check to see
+  # if they should be added to that target as well.
+  ldflags = []
+  if (is_android) {
+    ldflags += [
+      "-Bdynamic",
+      "-Wl,-z,nocopyreloc",
+    ]
+  } else {
+    # See the rpath_for... config above for why this is necessary for component
+    # builds. Sanitizers use a custom libc++ where this is also necessary.
+    if (is_component_build || using_sanitizer) {
+      configs = [ ":rpath_for_built_shared_libraries" ]
+    }
+    if (current_cpu == "mipsel") {
+      ldflags += [ "-pie" ]
+    }
+  }
+
+  if (!is_android || !use_gold) {
+    # Find the path containing shared libraries for this toolchain
+    # relative to the build directory. ${root_out_dir} will be a
+    # subdirectory of ${root_build_dir} when cross compiling.
+    _rpath_link = rebase_path(root_out_dir, root_build_dir)
+    if (shlib_subdir != ".") {
+      _rpath_link += "/$shlib_subdir"
+    }
+    if (is_android) {
+      _rebased_sysroot = rebase_path(sysroot, root_build_dir)
+      _rpath_link += ":$_rebased_sysroot/usr/lib"
+    }
+
+    ldflags += [
+      "-Wl,-rpath-link=$_rpath_link",
+
+      # TODO(GYP): Do we need a check on the binutils version here?
+      #
+      # Newer binutils don't set DT_RPATH unless you disable "new" dtags
+      # and the new DT_RUNPATH doesn't work without --no-as-needed flag.
+      "-Wl,--disable-new-dtags",
+    ]
+  }
+}
+
+config("no_exceptions") {
+  cflags_cc = [ "-fno-exceptions" ]
+  cflags_objcc = cflags_cc
+}
diff --git a/src/V8NativeScriptExtension.cc b/src/V8NativeScriptExtension.cc
new file mode 100644
index 0000000..5dafb13
--- /dev/null
+++ b/src/V8NativeScriptExtension.cc
@@ -0,0 +1,231 @@
+#include "V8NativeScriptExtension.h"
+#include "api.h"
+#include "checks.h"
+#include "contexts.h"
+#include "globals.h"
+#include "handles.h"
+#include "assembler.h"
+#include "keys.h"
+#include <assert.h>
+
+
+using namespace v8;
+
+template<typename T>
+class unsafe_arr
+{
+public:
+	unsafe_arr()
+		: m_capacity(16), m_size(0)
+	{
+		m_data = alloc_data(m_capacity);
+	}
+
+	void push_back(const T& e)
+	{
+		if (m_size == m_capacity)
+		{
+			resize();
+		}
+		m_data[m_size++] = e;
+	}
+
+	T* data() const
+	{
+		return m_data;
+	}
+
+	size_t size() const
+	{
+		return m_size;
+	}
+
+	static void release_data(T *data)
+	{
+		free(data);
+	}
+
+private:
+	T* alloc_data(size_t size)
+	{
+		T *data = reinterpret_cast<T*>(malloc(size * sizeof(T)));
+		return data;
+	}
+
+	void resize()
+	{
+		size_t capacity = 2 * m_capacity;
+		T *data = alloc_data(capacity);
+		size_t size = m_size * sizeof(T);
+		memcpy(data, m_data, size);
+		release_data(m_data);
+		m_data = data;
+		m_capacity = capacity;
+	}
+
+	size_t m_capacity;
+	size_t m_size;
+	T *m_data;
+};
+
+
+NativeScriptExtension::NativeScriptExtension()
+{
+}
+
+
+uint8_t* NativeScriptExtension::GetAddress(const Local<Object>& obj)
+{
+	i::Handle<i::JSReceiver> h = Utils::OpenHandle(*obj);
+
+	return h->address();
+}
+
+Local<Value>* NativeScriptExtension::GetClosureObjects(Isolate *isolate, const Local<Function>& func, int *length)
+{
+	unsafe_arr< Local<Value> > arr;
+
+	i::Handle<i::JSReceiver> receiver = Utils::OpenHandle(*func);
+
+	bool isFunction = receiver->IsJSFunction();
+
+	if (!isFunction) {
+		*length = static_cast<int>(arr.size());
+		return arr.data();
+	}
+
+	i::Handle<i::JSFunction> f = i::Handle<i::JSFunction>::cast(receiver);
+
+	i::Isolate* internal_isolate = reinterpret_cast<i::Isolate*>(isolate);
+
+	i::Context *cxt = f->context();
+
+	i::ContextLookupFlags cxtFlags = i::FOLLOW_CHAINS;
+
+	if ((cxt != nullptr) && (!cxt->IsNativeContext()))
+	{
+		i::JSFunction *closure = cxt->closure();
+
+		if (closure != nullptr)
+		{
+			i::SharedFunctionInfo *sharedFuncInfo = closure->shared();
+
+			if (sharedFuncInfo != nullptr)
+			{
+				i::ScopeInfo *si = sharedFuncInfo->scope_info();
+
+				if (si != nullptr)
+				{
+					int len = si->length();
+
+					for (int i = 0; i < len; i++)
+					{
+						i::Object *cur = si->get(i);
+
+						if ((cur != nullptr) && (cur->IsString()))
+						{
+							i::String *s = i::String::cast(cur);
+
+							i::Handle<i::String> name = i::Handle<i::String>(s, internal_isolate);
+
+							i::PropertyAttributes attr;
+							i::InitializationFlag init_flag; i::VariableMode var_mode;
+							int idx;
+
+							i::Handle<i::Object> o = cxt->Lookup(name, cxtFlags, &idx, &attr, &init_flag, &var_mode);
+
+							if (idx >= 0)
+							{
+								i::Handle<i::Context> hndCxt = i::Handle<i::Context>::cast(o);
+								i::Handle<i::Object> obj = i::Handle<i::Object>(hndCxt->get(idx), internal_isolate);
+
+								if (!obj.is_null() && obj->IsObject())
+								{
+									Local<Value> local = Utils::ToLocal(obj);
+
+									arr.push_back(local);
+								}
+							}
+						}
+					} // for
+				} // si != nullptr
+			} // sharedFuncInfo != nullptr
+		} // closure != nullptr
+	}
+
+	*length = static_cast<int>(arr.size());
+	return arr.data();
+}
+
+
+void NativeScriptExtension::ReleaseClosureObjects(Local<Value>* closureObjects)
+{
+	unsafe_arr< Local<Value> >::release_data(closureObjects);
+}
+
+
+void NativeScriptExtension::GetAssessorPair(Isolate *isolate, const Local<Object>& obj, const Local<String>& propName, Local<Value>& getter, Local<Value>& setter)
+{
+	i::Handle<i::JSObject> o = i::Handle<i::JSObject>::cast(Utils::OpenHandle(*obj));
+
+	i::Handle<i::String> intname = Utils::OpenHandle(*propName);
+
+	//Isolate* isolate = object->GetIsolate();
+
+	internal::LookupIterator it(o, intname, internal::LookupIterator::OWN);
+	i::Handle<i::Object> maybe_pair = it.GetAccessors();
+
+	// if (maybe_pair->IsAccessorPair()) {
+		i::MaybeHandle<i::Object> g = internal::AccessorPair::GetComponent(i::Handle<internal::AccessorPair>::cast(maybe_pair), i::AccessorComponent::ACCESSOR_GETTER);
+		if (!g.is_null())
+		{
+			getter = Utils::ToLocal(g.ToHandleChecked());
+		}
+
+		i::MaybeHandle<i::Object> s = internal::AccessorPair::GetComponent(i::Handle<internal::AccessorPair>::cast(maybe_pair), i::AccessorComponent::ACCESSOR_SETTER);
+		if (!s.is_null())
+		{
+			setter = Utils::ToLocal(s.ToHandleChecked());
+		}
+	// }
+}
+
+
+Local<Array> NativeScriptExtension::GetPropertyKeys(Isolate *isolate, const Local<Context>& context, const Local<Object>& object, bool& success)
+{
+	success = true;
+
+	i::Handle<i::JSObject> obj = i::Handle<i::JSObject>::cast(Utils::OpenHandle(*object));
+	i::Isolate* internal_isolate = reinterpret_cast<i::Isolate*>(isolate);
+	// i::Object* internal_object = reinterpret_cast<i::Object*>(Utils::OpenHandle(*object));
+
+	i::Handle<i::FixedArray> arr = i::KeyAccumulator::GetOwnEnumPropertyKeys(internal_isolate, obj);
+
+	int len = arr->length();
+
+	Local<Array> keys = Array::New(isolate, len);
+	for (int i = 0; i < len; i++)
+	{
+		i::Handle<i::Object> elem = i::Handle<i::Object>(arr->get(i), obj->GetIsolate());
+		Local<Value> val = Utils::ToLocal(elem);
+		Maybe<bool> res = keys->Set(context, i, val);
+		success &= (res.IsJust() && res.FromJust());
+	}
+
+	return keys;
+}
+
+int NativeScriptExtension::GetInternalFieldCount(const v8::Local<v8::Object>& object)
+{
+	i::Handle<i::JSObject> obj = i::Handle<i::JSObject>::cast(Utils::OpenHandle(*object));
+
+	int count = obj->GetInternalFieldCount();
+
+	return count;
+}
+
+void NativeScriptExtension::CpuFeaturesProbe(bool cross_compile) {
+	internal::CpuFeatures::Probe(cross_compile);
+}
diff --git a/src/V8NativeScriptExtension.h b/src/V8NativeScriptExtension.h
new file mode 100644
index 0000000..ede7550
--- /dev/null
+++ b/src/V8NativeScriptExtension.h
@@ -0,0 +1,26 @@
+#include "v8.h"
+#include "handles.h"
+
+namespace v8 {
+
+	class NativeScriptExtension {
+	public:
+		static uint8_t* GetAddress(const v8::Local<v8::Object>& obj);
+
+		static v8::Local<v8::Value>* GetClosureObjects(v8::Isolate *isolate, const v8::Local<v8::Function>& func, int *length);
+
+		static void ReleaseClosureObjects(v8::Local<v8::Value>* closureObjects);
+
+		static void GetAssessorPair(v8::Isolate *isolate, const v8::Local<v8::Object>& obj, const v8::Local<v8::String>& propName, v8::Local<v8::Value>& getter, v8::Local<v8::Value>& setter);
+
+		static v8::Local<v8::Array> GetPropertyKeys(v8::Isolate *isolate, const v8::Local<v8::Context>& context, const v8::Local<v8::Object>& object, bool& success);
+
+		static int GetInternalFieldCount(const v8::Local<v8::Object>& object);
+
+        static void CpuFeaturesProbe(bool cross_compile);
+	private:
+		NativeScriptExtension();
+
+		// static v8::internal::Handle<v8::internal::FixedArray> GetEnumPropertyKeys(const v8::internal::Handle<v8::internal::JSObject>& object, bool cache_result);
+	};
+}
diff --git a/src/api.cc b/src/api.cc
index 6858a32..004a76b 100644
--- a/src/api.cc
+++ b/src/api.cc
@@ -409,8 +409,22 @@ bool RunExtraCode(Isolate* isolate, Local<Context> context,
   ScriptOrigin origin(resource_name);
   ScriptCompiler::Source source(source_string, origin);
   Local<Script> script;
-  if (!ScriptCompiler::Compile(context, &source).ToLocal(&script)) return false;
-  if (script->Run(context).IsEmpty()) return false;
+  if (!ScriptCompiler::Compile(context, &source).ToLocal(&script)) {
+    base::OS::PrintError("# Script compile failed in %s@%d:%d\n%s\n",
+                         *String::Utf8Value(try_catch.Message()->GetScriptResourceName()),
+                         try_catch.Message()->GetLineNumber(context).FromJust(),
+                         try_catch.Message()->GetStartColumn(context).FromJust(),
+                         *String::Utf8Value(try_catch.Exception()));
+    return false;
+  }
+  if (script->Run(context).IsEmpty()) {
+    base::OS::PrintError("# Script run failed in %s@%d:%d\n%s\n",
+                         *String::Utf8Value(try_catch.Message()->GetScriptResourceName()),
+                         try_catch.Message()->GetLineNumber(context).FromJust(),
+                         try_catch.Message()->GetStartColumn(context).FromJust(),
+                         *String::Utf8Value(try_catch.Exception()));
+    return false;
+  }
   if (i::FLAG_profile_deserialization) {
     i::PrintF("Executing custom snapshot script %s took %0.3f ms\n", name,
               timer.Elapsed().InMillisecondsF());
--
2.5.5

